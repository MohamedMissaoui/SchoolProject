

<!doctype html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Welcome to Partitionnement et systeme de fichiers’s documentation! &mdash; documentation Partitionnement et systeme de fichiers 0.0.1</title>
    
    <link rel="stylesheet" href="_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <script type="text/javascript" src="_static/bizstyle.js"></script>
    <link rel="top" title="documentation Partitionnement et systeme de fichiers 0.0.1" href="#" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index général"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="#">documentation Partitionnement et systeme de fichiers 0.0.1</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table des Matières</a></h3>
  <ul>
<li><a class="reference internal" href="#">Welcome to Partitionnement et systeme de fichiers&#8217;s documentation!</a></li>
<li><a class="reference internal" href="#les-systemes-de-fichiers">LES SYSTEMES DE FICHIERS&nbsp;:</a><ul>
<li><a class="reference internal" href="#quesquun-systeme-de-fichier">Quesqu’un systeme de fichier&nbsp;?</a></li>
<li><a class="reference internal" href="#systeme-de-fichier-journalise">Système de fichier journalisé</a></li>
<li><a class="reference internal" href="#systeme-de-fichier-non-journalise">Système de fichier non journalisé</a></li>
<li><a class="reference internal" href="#swap">SWAP</a></li>
<li><a class="reference internal" href="#fragmentation">FRAGMENTATION</a></li>
<li><a class="reference internal" href="#fstab">FSTAB</a></li>
<li><a class="reference internal" href="#les-commandes">LES COMMANDES</a><ul>
<li><a class="reference internal" href="#source">source :</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.txt"
            rel="nofollow">Montrer le code source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Recherche rapide</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Saisissez un mot clef ou un nom de module, classe ou fonction.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="welcome-to-partitionnement-et-systeme-de-fichiers-s-documentation">
<h1>Welcome to Partitionnement et systeme de fichiers&#8217;s documentation!<a class="headerlink" href="#welcome-to-partitionnement-et-systeme-de-fichiers-s-documentation" title="Lien permanent vers ce titre">¶</a></h1>
<p>Il est permis de copier, distribuer et/ou modifier ce document en respect des termes de la « GNU Free
Documentation License », Version 1.3 ou supérieure telle que publiée par la Free Software Foundation;
avec la section &#8220;Licence&#8221; inaltérable, sans texte de couverture et sans texte de dernière page de
couverture. Une copie de la licence est incluse à la section intitulée &#8220;GNU Free Documentation Licence&#8221; ou
peut être obtenu depuis l’adresse suivante: http ://www.gnu.org/copyleft/fdl.html</p>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
</div>
<div class="section" id="les-systemes-de-fichiers">
<h1>LES SYSTEMES DE FICHIERS&nbsp;:<a class="headerlink" href="#les-systemes-de-fichiers" title="Lien permanent vers ce titre">¶</a></h1>
<div class="section" id="quesquun-systeme-de-fichier">
<h2>Quesqu’un systeme de fichier&nbsp;?<a class="headerlink" href="#quesquun-systeme-de-fichier" title="Lien permanent vers ce titre">¶</a></h2>
<p>Dans le cœur d&#8217;un ordinateur, tout est constitué de 1 et de 0, mais l&#8217;organisation de ces données n&#8217;est pas aussi simple. Un bit est un 1 ou un 0 ; un octet (byte en anglais) est composé de huit bits ; un kilo-octet binaire(kibibyte) est un groupe de 1024 octets ; un méga-octet binaire(mebibyte) se constitue de 1024 kilo-octets binaires ; et ainsi se poursuit la chaîne.</p>
<div class="line-block">
<div class="line">Un disque dur (hard drive ou hard disk) stocke toutes vos données : à chaque fois que vous enregistrez un fichier, vous écrivez des milliers de 1 et de 0 sur un disque métallique, le piquant littéralement et créant une indentation qui pourra plus tard être relue en tant que 1 ou 0 par votre ordinateur. En réalité, vous magnétisez des milliers de petits bâtons (que nous appellerons clusters) qui seront polarisés dans un sens ou dans un autre (N-S ou S-N) ; cette polarisation différente sera ré-interprétée plus tard par l&#8217;ordinateur en tant que 1 ou 0.</div>
</div>
<div class="line-block">
<div class="line">Il y a tellement de données sur un disque dur qu&#8217;il doit obligatoirement y avoir un moyen de les organiser. C&#8217;est un peu comme les anciens classeurs de cartes d&#8217;identification de livres dans une bibliothèque municipale, dans lesquels tous les livres sont recensés : sans ces index, il serait impossible de retrouver facilement les livres que nous recherchons. Les bibliothèques utilisent pour la plupart le système décimal Dewey pour organiser les livres en sujets ; il existe aussi d&#8217;autres systèmes de classification arrivant à un résultat similaire, bien qu&#8217;aucun d&#8217;entre eux n&#8217;ait atteint la même popularité que le système de Dewey.</div>
</div>
<div class="line-block">
<div class="line">Les systèmes de fichiers jouent exactement le même rôle que ces index : organiser les fichiers de votre ordinateur sur votre disque dur de façon à pouvoir les retrouver lorsque vous en aurez besoin. Les systèmes de fichiers les plus utilisés à l&#8217;heure actuelle sont sûrement le FAT32 et le NTFS, qui sont les deux seuls systèmes de fichiers que Microsoft® Windows® peut nativement lire. Mais, tout comme il existe d&#8217;autres systèmes pour classer des livres dans une bibliothèque, il existe de nombreux autres systèmes de fichiers : ext2, ext3, ReiserFS, JFS, XFS,…</div>
</div>
</div>
<div class="section" id="systeme-de-fichier-journalise">
<h2>Système de fichier journalisé<a class="headerlink" href="#systeme-de-fichier-journalise" title="Lien permanent vers ce titre">¶</a></h2>
<p>Le système de fichiers journalisé est un système de fichiers tolérant/résistant aux pannes qui permet d&#8217;assurer l&#8217;intégrité des données en cas de problème matériel, de panne de courant (ou débranchement à chaud) ou d&#8217;arrêt brutal du système. Cette fonctionnalité est assurée par la tenue d&#8217;un journal référençant les opérations d&#8217;écriture sur le support physique avant que ce dernier ne soit réellement mis à jour. Le système de fichiers doit permettre une reprise d&#8217;activité à la suite d&#8217;une coupure brutale, telle un arrêt électrique. Les métadonnées doivent alors rester cohérentes et à jour. La journalisation permet d&#8217;optimiser le contrôle d&#8217;intégrité du système de fichiers, réduisant ainsi le temps de redémarrage du système, critère important dans les environnements qui ont besoin d&#8217;une haute disponibilité.</p>
<div class="line-block">
<div class="line">La journalisation du système de fichier assure la cohérence des données en utilisant un journal. Ce journal est un fichier spécial qui enregistre les changements destinés au système de fichier, dans une mémoire circulaire. À intervalles réguliers, le journal est appliqué sur le système de fichier. Si une interruption électrique intervient, le journal peut être utilisé comme point de départ afin de récupérer les informations non sauvegardées, et ainsi assurer l&#8217;intégrité des données du système de fichier.</div>
</div>
<div class="line-block">
<div class="line">Il y a 2 méthode de journalisation, celle avec des journaux physique et celle avec des journaux logique.</div>
</div>
<div class="line-block">
<div class="line">Journaux physique&nbsp;: Le journal physique enregistre les modifications de données sur le support avant que celles-ci soient opérées. Les entrées contenues dans ce journal comprennent les données à écrire, ainsi qu&#8217;une somme de contrôle, afin d&#8217;assurer l&#8217;intégrité de celles-ci. Ceci permet d&#8217;éviter d&#8217;écrire des données pour lesquelles l&#8217;entrée du journal est incomplète. Cette méthode pénalise les performances, car chaque écriture nécessite une double écriture sur le support physique, une pour le journal, et une pour les données effectives. Elle est néanmoins acceptée en raison de la garantie de la cohérence des données qu&#8217;elle permet.</div>
</div>
<div class="line-block">
<div class="line">Journaux logique&nbsp;: Le journal logique ne stocke que les métadonnées, sacrifiant la tolérance aux pannes pour de meilleures performances. Il permet lui aussi le rejeu des opérations, mais peut lier des métadonnées journalisées à des données non journalisées, causant ainsi une corruption des données.</div>
</div>
<div class="line-block">
<div class="line"><strong>Exemple de système de fichier journalisé&nbsp;:</strong></div>
</div>
<p>Ext3, Ext4 ou encore BTRFS sont des système de fichier journalisé.</p>
<div class="line-block">
<div class="line">Ext3 :  est une extension de Ext2, auquel on a ajouté une fonction de journalisation. Il est donc</div>
</div>
<p>possible de convertir une partition ext2 en une partition ext3 de manière simple, la seule modification à ajouter étant le journal. Il n&#8217;est utilisable que sur les systèmes Linux.
Avec ce système de fichier l’utilisateur à la possibilité de choisir parmi trois mode de journalisation qui sont le mode Journal(correspond à la journalisation physique), mode Writeback, mode Ordered(mode par défaut).</p>
<div class="line-block">
<div class="line">Ext4 est son successeur, il permet la sauvegarde de fichier plus volumineux et est plus fiable grace à l&#8217;utilisation du checksum à chaque ecriture dans le journal et est plus performant sur les fichier volumineux.</div>
</div>
<div class="line-block">
<div class="line">BTRFS est un système de fichiers des années 2010 fondé sur le Copy-On-Write (copie sur écriture) sous licence GNU GPL, développé conjointement par Oracle, Red Hat, Fujitsu, Intel, SUSE, STRATO AG&nbsp;(en) et autres. En 2012, alors qu&#8217;il n&#8217;était pas encore considéré comme tout-à-fait stable7, un effort intense de développement et de test est fourni par la communauté afin de faire de Btrfs le successeur de ext4 et ext3, systèmes de fichiers habituels des distributions Linux. OpenSuse 13.2 propose dès son lancement Btrfs par défaut pour la partition racine afin d&#8217;assurer la sécurité et laisse le choix entre ext4 et XFS.</div>
</div>
<div class="line-block">
<div class="line">Btrfs offre les fonctionnalités suivantes absentes d&#8217;autres systèmes de fichiers&nbsp;:</div>
</div>
<ul class="simple">
<li>Instantané (snapshots),</li>
<li>somme de contrôle (CheckSum).</li>
</ul>
<p>Ces caractéristiques sont importantes pour les systèmes Linux, serveurs comme postes clients, car les tailles de stockage comme les configurations tendent à augmenter et à se complexifier.
La technique de l&#8217;instantané, en particulier, garantit de pouvoir faire une sauvegarde cohérente des fichiers du système tels qu&#8217;ils étaient au moment précis de l&#8217;instantané, même si la sauvegarde dure plusieurs heures et que de nombreux fichiers sont modifiés entre temps.</p>
</div>
<div class="section" id="systeme-de-fichier-non-journalise">
<h2>Système de fichier non journalisé<a class="headerlink" href="#systeme-de-fichier-non-journalise" title="Lien permanent vers ce titre">¶</a></h2>
<p>Vous l’aurez compris un système de fichier non journalisé est un systeme de fichier moin tolérent au panne. Suite à un incident il existe 2 procédé&nbsp;:</p>
<ul class="simple">
<li>Procédé des mises à jour prudentes qui, à un instant précis, rend le système de fichiers cohérent.</li>
<li>Procédé des programmes &#8220;éboueurs&#8221;.</li>
</ul>
<div class="line-block">
<div class="line">Le premier procédé consiste, à un instant précis, à ne pas laisser le système de fichiers incohérent. Ce procédé est très problématique car ne pas passer par une étape laissant le système dans une position incohérente est difficile. Par exemple, lorsqu&#8217;on crée un fichier, il faut ajouter ce fichier dans le répertoire et créer l&#8217;inode de ce répertoire. Ces opérations ne sont pas possibles simultanément et donc il se passe toujours un instant où l&#8217;inode est affecté au fichier mais pas au répertoire, ou l&#8217;inverse.</div>
</div>
<div class="line-block">
<div class="line">Le deuxième procédé est celui employé par le système de fichier ext2. Il utilise l&#8217;utilitaire fsck pour vérifier l&#8217;intégrité et réparer les données. L&#8217;utilitaire est lancé au démarrage si le système détecte un problème sur le système de fichiers. À la suite de cela, l&#8217;utilitaire vérifie l&#8217;intégralité du disque. L&#8217;inconvénient majeur de cette méthode est le temps d’exécution qui est proportionnel à la taille du support. Pour procéder à la vérification, le déroulement de l&#8217;utilitaire fsck se décompose en 6 phases&nbsp;:</div>
</div>
<ul class="simple">
<li>Passe 1&nbsp;: vérification des i-nœuds, des blocs et des tailles</li>
<li>Passe 2&nbsp;: vérification de la structure des répertoires</li>
<li>Passe 3&nbsp;: vérification de la connectivité des répertoires</li>
<li>Passe 3A&nbsp;: optimisation des répertoires</li>
<li>Passe 4&nbsp;: vérification des compteurs de référence</li>
<li>Passe 5&nbsp;: vérification de l&#8217;information du sommaire de groupe</li>
</ul>
<div class="line-block">
<div class="line">On remarque que le temps d’exécution dépend de la taille du disque. De ce fait, plus la taille du support est importante, plus l’exécution de fsck est longue.</div>
</div>
<div class="line-block">
<div class="line">Il était donc intéressant de pouvoir mélanger les deux procédés pour avoir une méthode de récupération beaucoup plus rapide.</div>
</div>
<div class="line-block">
<div class="line"><strong>Exemple de système de fichier non journalisé&nbsp;:</strong></div>
</div>
<p><a href="#id1"><span class="problematic" id="id2">|</span></a>Ext2&nbsp;: Les fonctionnalités standard de  permettent d&#8217;accéder à des partitions de 4 téraoctets (1 téraoctets = 1 024 gigaoctets), alors que la version ext1 ne permettait que des partitions de 2 gigaoctets (1 gigaoctets = 1 024 mégaoctets). La taille maximale des fichiers avec un système ext2 standard est de 2 gigaoctets. De plus, lors de la création du système de fichiers, le système réserve une certaine quantité d&#8217;espace pour le super-utilisateur (root), en général 5&nbsp;%. Ceci permet au super-utilisateur de pouvoir se connecter sur le système et de faire des tâches administratives quand le système de fichiers est plein pour les utilisateurs. Ext2Fs gère aussi les noms de fichiers longs (255 caractères) et prend en compte tous les caractères excepté &#8220;NUL&#8221; et &#8220;/&#8221;.</p>
<p><strong>Les lacunes&nbsp;:</strong>
Bien qu&#8217;ayant été conçu de façon intelligente, ce système de fichiers possède des limites inacceptables pour des machines nécessitant une disponibilité importante. Le temps de vérification du système de fichiers est proportionnel à sa taille, puisque le système va lire tous les inodes et vérifier leurs cohérences. Par conséquent, plus le système de fichiers est important, et plus cette vérification est longue. De plus, un crash peut détruire, ou rendre inaccessibles des données pourtant déjà présentes sur le disque.</p>
<div class="line-block">
<div class="line">Une autre limitation importante vient de l&#8217;absence d&#8217;ACL (Access Control Lists soit listes de contrôle d&#8217;accès) utilisées au niveau du système de fichiers, de manière native par Linux. La présence d&#8217;ACL permet en effet de gérer de manière très fine les droits d&#8217;accès aux fichiers.</div>
</div>
<div class="line-block">
<div class="line">On peut donc considérer que ces aspects sont les caractéristiques qui vont permettre la création de nouveaux systèmes de fichiers. Afin de maintenir la plus haute disponibilité possible, ceux-ci devront permettre de redémarrer rapidement après un arrêt brutal, dans un temps qui n&#8217;est pas en relation directe avec leur taille. De plus, les coûts de maintenance de ces systèmes devront être les plus faibles possibles, autant au niveau du temps qu&#8217;au niveau des ressources matérielles. Le principal problème rencontré aujourd&#8217;hui reste la sauvegarde des données du système de fichiers. En effet, si on veut effectuer une sauvegarde rigoureuse du système de fichiers, il faut fixer une date précise à laquelle le système de fichiers sera sauvegardé. Cependant, cette opération n&#8217;étant pas instantanée, la modification de ce dernier durant la sauvegarde peut conduire, dans certains cas, à une incohérence de fichiers entre eux. La meilleure solution serait d&#8217;arrêter le système de fichiers pour effectuer la sauvegarde, ce qui n&#8217;est pas acceptable dans la plupart des cas. Il faudrait donc pouvoir figer l&#8217;aspect du système de fichiers, sans empêcher les utilisateurs de travailler dessus. Cette solution peut également apporter la fonctionnalité de pouvoir &#8220;défaire&#8221; une opération malencontreuse, comme un effacement accidentel d&#8217;un fichier, ou l&#8217;écrasement d&#8217;un fichier par un autre. Ensuite, il sera sans doute très utile de pouvoir redimensionner la taille du système de fichiers d&#8217;une manière souple, donc non-destructive.</div>
</div>
<div class="line-block">
<div class="line">Il reste également l&#8217;aspect de la confidentialité des données des utilisateurs sur le système de fichiers. Il faudrait qu&#8217;une personne ayant un accès physique sur le média ne soit pas capable de pouvoir reconstituer l&#8217;ensemble des données présentes sur ce dernier.</div>
</div>
<div class="line-block">
<div class="line"><strong>Système de fichier distribué et en réseau&nbsp;:</strong></div>
</div>
<div class="line-block">
<div class="line">Le Network File System est une technologie (un mécanisme ou un protocole pour faire simple) permettant d&#8217;accéder aux fichiers présents sur des machines distantes exactement comme s&#8217;ils sont locaux.</div>
</div>
<div class="line-block">
<div class="line">Sous les systèmes UNIX (y compris linux), il est considéré comme un système de fichiers à part entière.</div>
</div>
<div class="line-block">
<div class="line">Proposé par Sun Microsystem, le protocole NFS s&#8217;est imposé comme un standard dans le monde UNIX mais dépasse le simple cadre du monde UNIX.</div>
<div class="line">En effet il s&#8217;appuie sur une représentation standard des objets proposée par le protocole XDR et le mécanisme d&#8217;appels de procédures distantes implémenté par le protocole RPC (Remote Procedure Call). Tous ces deux protocoles sont aussi l&#8217;oeuvre de Sun Microsystem.</div>
</div>
<div class="line-block">
<div class="line">En fait NFS est composé de quatre protocoles distincts qui reposent tous sur les RPC et donc sur le programme rpc.portmap. Un des rôles de ce programme est de convertir les numéros de programmes RPC en numéros de ports. Quand un serveur RPC démarre, il va préciser à portmap quel port il utilisera et les numéros de programmes RPC qu&#8217;il gère. Quand un client souhaite envoyer une requête RPC vers un numéro de programme donné, il contacte d&#8217;abord le serveur portmap pour obtenir le numéro de port sur lequel tourne le programme souhaité. Ensuite, il adresse les paquets RPC au port concerné.</div>
</div>
<div class="line-block">
<div class="line"><strong>Disque virtuel&nbsp;:</strong></div>
</div>
<p>Un disque dur virtuel fournit un espace de stockage pour une machine virtuelle. Au sein de la machine virtuelle, le disque dur virtuel est représenté comme un disque physique. La machine virtuelle l&#8217;utilise également comme s&#8217;il s&#8217;agissait d&#8217;un disque physique. Techniquement, le disque dur virtuel est un fichier résidant sur un disque physique auquel le système d&#8217;exploitation hôte peut accéder. Sur le disque physique, le fichier du disque dur virtuel est stocké au format .vhd. En règle générale, vous pouvez stocker un fichier .vhd sur n&#8217;importe quel type de dispositif de stockage accessible par le système d&#8217;exploitation hôte.</p>
<div class="line-block">
<div class="line">Les types de disques et les exigences de stockage sont les suivants&nbsp;:</div>
</div>
<ul class="simple">
<li>Disque dur virtuel de taille dynamique : Ce type requiert un minimum de 8&nbsp;Mo d&#8217;espace libre sur le support de stockage physique. La taille du disque (et du fichier .vhd) croît en proportion de l&#8217;utilisation du disque, jusqu&#8217;à la limite spécifiée lors de la création du disque.</li>
<li>Disque dur virtuel fixe : Ce type de disque requiert un espace de stockage physique équivalent à la taille spécifiée lors de sa création. La taille du fichier .vhd est identique à celle du disque dur virtuel et reste inchangée.</li>
<li>Disque dur virtuel de différenciation : Ce type requiert un espace de stockage physique réduit lors de la création du disque, puis un espace de plus en plus important à mesure que la taille du disque augmente. La taille maximale d&#8217;un disque de différenciation est régie par la taille maximale de son disque dur parent.</li>
</ul>
<div class="line-block">
<div class="line"><strong>Snapshot&nbsp;:</strong></div>
</div>
<p>En informatique, un instantané est l&#8217;état d&#8217;un système à un instant donné. On utilise particulièrement cette notion dans le cadre des systèmes de fichiers, des bases de données ou des machines virtuelles. Pour réaliser un instantané, on utilise en général une méthode qui diffère d&#8217;une sauvegarde traditionnelle du système par le fait que les données à sauvegarder ne sont copiées sur le périphérique de sauvegarde qu&#8217;au moment où elles sont modifiées sur le système dont on crée l&#8217;instantané.</p>
<div class="line-block">
<div class="line">Une sauvegarde complète d&#8217;une grande quantité de données peut être longue à exécuter. Par ailleurs, celle-ci nécessite généralement le verrouillage des données à sauvegarder pour empêcher que des données en cours de sauvegarde ne soient modifiées et ne produisent ainsi une sauvegarde qui ne soit pas représentative du système à un instant donné. Cela ne pose pas de problème particulier pour effectuer des sauvegardes sur des ordinateurs personnels ou des serveurs internes de petites entreprises, puisqu&#8217;il est parfaitement acceptable qu&#8217;un tel système puisse être indisponible durant un certain laps de temps. Cependant, sur des serveurs utilisés à grande échelle, exigeant de grands uptimes, on ne peut recourir à de telles méthodes.</div>
</div>
<div class="line-block">
<div class="line">Pour éviter cela, on peut créer un instantané. On réserve d&#8217;abord sur le périphérique cible un espace de taille suffisante pour contenir les données à sauvegarder. Les données à copier et l&#8217;instantané ainsi initialisé sont divisés en blocs de données, de taille fixe ou variable&nbsp;; dans l&#8217;instantané, aucune donnée n&#8217;est encore présente, mais chaque bloc contient un pointeur vers le bloc correspondant sur le système d&#8217;origine. Lorsqu&#8217;un bloc des données à sauvegarder est modifié, les données d&#8217;origine de ce bloc sont copiées dans le bloc correspondant de l&#8217;instantané avant que les modifications ne soient écrites.</div>
</div>
<div class="line-block">
<div class="line">Cette méthode ne permet cependant pas de protéger les données contre une panne de disque dur par exemple, puisque seules les données qui auront été modifiées seront copiées dans l&#8217;instantané. Pour pallier cela, on commence parfois par copier la totalité du système à sauvegarder par la méthode traditionnelle, après quoi on peut créer des instantanés successifs dont les parties non modifiées pointeront non pas vers les données originales mais vers la première copie complète.</div>
</div>
<p><a class="reference external" href="https://www.ibisc.univ-evry.fr/~petit/Enseignement/AdminSystem/IUP-ASR/2004-2005/snapshot.pdf">https://www.ibisc.univ-evry.fr/~petit/Enseignement/AdminSystem/IUP-ASR/2004-2005/snapshot.pdf</a></p>
<div class="line-block">
<div class="line">Les commandes&nbsp;: La création de snapshot avec LVM se fait de façon simple : on crée un nouveau volume logique qui contient le snapshot, on monte ce volume, on effectue sa sauvegarde, on démonte le volume puis on le détruit.</div>
<div class="line">Création du snapshot :</div>
</div>
<p>On crée ici le snapshot qui apparaitra comme comme un duplicat du volume logique qu&#8217;on souhaite
sauvegarder. Il faut prévoir suffisemment de place pour ce volume logique (environ 500Mos) et
spécifier à la création qu&#8217;il s&#8217;agit d&#8217;un volume logique.</p>
<div class="line-block">
<div class="line"><code class="docutils literal"><span class="pre">#</span> <span class="pre">lvcreate</span> <span class="pre">-L500M</span> <span class="pre">-s</span> <span class="pre">-n</span> <span class="pre">snapshot</span> <span class="pre">/dev/volume1/part1</span></code></div>
</div>
<div class="line-block">
<div class="line">Si il n&#8217;y a pas assez de place pour le snapshot, celui ci est désactivé.</div>
<div class="line">Si le système de fichier utilisé est XFS, il faut utiliser la commande :</div>
</div>
<div class="line-block">
<div class="line"><code class="docutils literal"><span class="pre">#</span> <span class="pre">xfs_freeze</span> <span class="pre">-f</span></code></div>
</div>
<div class="line-block">
<div class="line">pour verrouiller le système de fichier avant la création du snapshot puis le dévérouiller avec :</div>
</div>
<div class="line-block">
<div class="line"><code class="docutils literal"><span class="pre">#</span> <span class="pre">xfs_freeze</span> <span class="pre">-u</span></code></div>
</div>
</div>
<div class="section" id="swap">
<h2>SWAP<a class="headerlink" href="#swap" title="Lien permanent vers ce titre">¶</a></h2>
<p>Le swap est appelé en français espace ou partition d&#8217;échange.
| Linux divise la RAM (mémoire vive) physique en blocs de mémoire appelés pages. Le swapping est le procédé par lequel une page de mémoire est copiée vers un espace prédéfini sur le disque dur, appelé swap (espace d&#8217;échange), permettant de libérer cette page mémoire. Les tailles combinées de la mémoire physique et de l&#8217;espace d&#8217;échange correspondent à la quantité de mémoire virtuelle disponible.</p>
<div class="line-block">
<div class="line">L&#8217;espace d&#8217;échange, aussi connu sous le nom de mémoire virtuelle, peut être présent sous forme de partition ou de fichier, et peut être créé ou supprimé à n&#8217;importe quel moment. L&#8217;espace d&#8217;échange est recommandé pour les machines ayant moins de 1 Go de mémoire vive (RAM), mais dépend surtout des préférences personnelles du propriétaire de l&#8217;ordinateur. La seule contrainte vient lors de l&#8217;activation de l&#8217;hibernation, nécessitant un fichier d&#8217;échange de taille supérieur ou égale à la taille de mémoire vive physiquement installée.</div>
</div>
</div>
<div class="section" id="fragmentation">
<h2>FRAGMENTATION<a class="headerlink" href="#fragmentation" title="Lien permanent vers ce titre">¶</a></h2>
<div class="line-block">
<div class="line">Il n’y a pas vraiment de fragmentation sous linux étant donnée que les systeme de fichier sont fait de tel sorte à ne pas se fragmenter.</div>
</div>
<div class="line-block">
<div class="line">Les systèmes Ext2, Ext3, et Ext4 (systèmes de fichiers utilisés par la plupart des distributions Linux actuelles) organisent et répartissent les fichiers sur le disque dur de manière intelligente. Au lieu de placer les fichiers près les uns des autres sur le disque dur, ces systèmes de fichiers dispersent les fichiers sur tout le disque, laissant une grande quantité d&#8217;espace libre entre eux. Quand un fichier est modifié et que sa taille augmente, il y a généralement beaucoup d&#8217;espace libre pour enregistrer le fichier sur des secteurs contiguë. S&#8217;il y a fragmentation, le système de fichiers tentera de déplacer les fichiers afin de réduire la fragmentation en utilisation normale sans avoir besoin d&#8217;un utilitaire de défragmentation.</div>
</div>
<div class="line-block">
<div class="line">En raison de la façon dont ces systèmes fonctionnent, il y aura fragmentation importante lorsque votre disque sur se remplit à une capacité de 95% (voire 80%). Cependant, le système de fichiers est conçu pour éviter la fragmentation en utilisation normale.</div>
</div>
<div class="line-block">
<div class="line">Si vous avez des problèmes avec la fragmentation sous Linux, vous avez probablement besoin d&#8217;un plus gros disque dur. Si vous avez réellement besoin de défragmenter un système de fichiers Linux, la façon la plus simple et sans doute la plus fiable de faire est de copier tous les fichiers de la partition sur un autre média, effacer les fichiers de la partition, puis copier les fichiers à nouveau sur la partition. Le système de fichiers saura répartir les fichiers intelligemment sur le disque.</div>
</div>
<div class="line-block">
<div class="line">Vous pouvez vérifier la fragmentation de votre disque à l&#8217;aide de la commande <code class="docutils literal"><span class="pre">fsck</span></code>.</div>
</div>
</div>
<div class="section" id="fstab">
<h2>FSTAB<a class="headerlink" href="#fstab" title="Lien permanent vers ce titre">¶</a></h2>
<p>Le fichier fstab (file systems table) est la table des différents systèmes de fichiers sur un ordinateur sous Unix/Linux&nbsp;: il contient une liste des disques utilisés au démarrage et des partitions de ces disques. Pour chaque partition, il indique comment elle sera utilisée et intégrée à l’arborescence du système de fichiers global (c&#8217;est-à-dire le point de montage). Il se trouve généralement à /etc/fstab.</p>
<div class="line-block">
<div class="line">Voici un exemple de fichier fstab :</div>
</div>
<div class="line-block">
<div class="line"># &lt;file system&gt;        &lt;dir&gt;         &lt;type&gt;    &lt;options&gt;             &lt;dump&gt; &lt;pass&gt;</div>
<div class="line">/dev/sda1              /             ext4      defaults              1      1</div>
<div class="line">/dev/hdxx              /usr          ext4      defaults              1      1</div>
<div class="line">/dev/sda5              swap          swap      defaults              0      0</div>
</div>
<div class="line-block">
<div class="line">&lt;file systems&gt; - définit l&#8217;équipement de stockage</div>
<div class="line">&lt;dir&gt; - indique à la commande de montage où monter le &lt;file system&gt;.</div>
<div class="line">&lt;type&gt; - définit le type de système de fichiers pour monter le support ou la partition. Un grand nombre de systèmes de fichiers sont supportés, par exemple : ext2, ext3, ext4, reiserfs, xfs, jfs, smbfs, iso9660, vfat, ntfs, swap, and auto. Le type &#8216;auto&#8217; laisse la commande de montage deviner quel type de système de fichiers utilisés.</div>
<div class="line">&lt;options&gt; - définit des options particulières pour les systèmes de fichier. Certaines options sont pour le système de fichiers lui même.(auto,exec,ro,rw...)</div>
<div class="line">&lt;dump&gt; - est utilisé par l&#8217;utilitaire dump pour décider quand faire des sauvegardes. Quand il est installé, dump vérifie le chiffre inscrit et décide si le système de fichiers doit être sauvegardé. Les valeurs possibles sont 0 et 1. Si 0, dump va ignorer le système de fichier, si 1, dump fera une sauvegarde.</div>
<div class="line">&lt;pass&gt; fsck lit le chiffre &lt;pass&gt; et détermine dans quel ordre les systèmes de fichiers vont être vérifiés. Le champ peut prendre les valeurs 0,1 et 2. Le système de fichiers root devra avoir la priorité la plus haute : 1, tout les autres systèmes que vous voulez vérifier devront avoir un 2. Les systèmes de fichiers avec un &lt;pass&gt; à 0 ne seront pas vérifier par l&#8217;utilitaire fsck.</div>
</div>
</div>
<div class="section" id="les-commandes">
<h2>LES COMMANDES<a class="headerlink" href="#les-commandes" title="Lien permanent vers ce titre">¶</a></h2>
<p><strong>mount&nbsp;:</strong></p>
<div class="line-block">
<div class="line">La commande mount permet de relier une partition ou un périphérique à un répertoire, répertoire par lequel les données présentes sur la partition ou le périphérique sont accessibles.</div>
<div class="line">Pour monter un périphérique ou une partition avec la commande mount, il faut indiquer&nbsp;:</div>
</div>
<ul class="simple">
<li>le type du système de fichiers par l&#8217;option -t</li>
<li>le fichier spécial représentant le périphérique ou la partition (généralement /dev/<a href="#id3"><span class="problematic" id="id4">*</span></a>)&nbsp;;</li>
<li>le répertoire de montage.</li>
</ul>
<div class="line-block">
<div class="line">Certaines indications peuvent être omises lorsqu&#8217;elles sont spécifiées dans le fichier de configuration listant les points de montage par défaut (/etc/fstab sous Linux). On peut omettre le type de système de fichiers si la version de mount utilisée est assez «&nbsp;intelligente&nbsp;». Par contre, même en l&#8217;indiquant, on ne pourra jamais monter un système de fichiers que le noyau Unix ne sait pas gérer (parce qu&#8217;il n&#8217;a pas été configuré pour l&#8217;utiliser par exemple).</div>
</div>
<div class="line-block">
<div class="line">Lorsque le montage a réussi, une mise à jour est effectuée dans un fichier système recensant les montages en cours (fichier /etc/mtab sous Linux). L&#8217;option -n de mount permet d&#8217;éviter cette mise à jour dans des cas bien particuliers où le montage échouerait pour cette raison (si l&#8217;on travaille sur un système de fichiers chrooté en lecture seule par exemple).</div>
</div>
<div class="line-block">
<div class="line">On peut également sous les Unix modernes monter des fichiers qui constituent un système de fichiers à eux-seuls (loopback), grâce à l&#8217;option -loop. Ceci est particulièrement utile dans le cas d&#8217;images représentant des disquettes, CD-ROM, DVD. Les commandes dd et mkisofs peuvent aider à fabriquer de tels fichiers.</div>
</div>
<div class="line-block">
<div class="line">Il est possible, sous certaines configurations, de monter (recouvrement total ou partiel) par dessus d&#8217;autres systèmes déjà montés.</div>
</div>
<div class="line-block">
<div class="line">Exemple de commande avec mount :</div>
</div>
<div class="line-block">
<div class="line">Disont que l&#8217;on vient de modifier le fichier /etc/fstab pour qu&#8217;il monte automatiquement une certaine partition au démmarage. Pas besoin de redemarrer l&#8217;ordinateur on peut utiliser la commande :</div>
</div>
<div class="line-block">
<div class="line"><code class="docutils literal"><span class="pre">mount</span> <span class="pre">-a</span></code></div>
</div>
<div class="line-block">
<div class="line">Si on veut monter le contenu de /dev/sda1 en ext2 dans le repertoire /mnt/test :</div>
</div>
<div class="line-block">
<div class="line"><code class="docutils literal"><span class="pre">mount</span> <span class="pre">-t</span> <span class="pre">ext2</span> <span class="pre">/dev/sda1</span> <span class="pre">/mnt/test</span></code></div>
</div>
<div class="line-block">
<div class="line">Par exemple, la commande ci-dessous permet de lire un CD-ROM en montant le périphérique /dev/cdrom  sur /media/cdrom en indiquant que le système de fichiers est ISO 9660.</div>
</div>
<div class="line-block">
<div class="line"><code class="docutils literal"><span class="pre">#</span> <span class="pre">mount</span> <span class="pre">-t</span> <span class="pre">iso9660</span> <span class="pre">-o</span> <span class="pre">loop/dev/cdrom</span> <span class="pre">/mnt/cdrom</span></code></div>
</div>
<div class="line-block">
<div class="line">L&#8217;option bind permet de lié un repertoire à un autre.</div>
</div>
<div class="line-block">
<div class="line"><code class="docutils literal"><span class="pre">mount</span> <span class="pre">--bind</span> <span class="pre">/dev/sda1</span> <span class="pre">/home/test</span></code></div>
</div>
<p><strong>umount&nbsp;:</strong></p>
<p>Pour démonter une partition ou un périphérique, il faut utiliser la commande umount. Par exemple&nbsp;:</p>
<div class="line-block">
<div class="line"><code class="docutils literal"><span class="pre">umount</span> <span class="pre">/mnt/cdrom</span></code></div>
</div>
<div class="line-block">
<div class="line">Le démontage ne marche que si la partition n&#8217;est pas utilisée, à savoir&nbsp;:</div>
</div>
<ul class="simple">
<li>aucun fichier n&#8217;est en train d&#8217;être lu ou écrit sur la partition&nbsp;;</li>
<li>aucun processus n&#8217;a son répertoire de travail sur la partition.</li>
</ul>
<div class="line-block">
<div class="line">Si le démontage est refusé, on peut utiliser la commande fuser/lsof pour savoir quels processus l&#8217;utilisent. Par exemple (si le démontage de /media/cdrom est refusé)&nbsp;:</div>
</div>
<div class="line-block">
<div class="line"><code class="docutils literal"><span class="pre">fuser</span> <span class="pre">/mnt/cdrom</span></code></div>
</div>
<div class="line-block">
<div class="line">Lorsque le démontage a eu lieu, le fichier /etc/mtab (Linux)  est mis à jour.</div>
</div>
<p><strong>fdisk&nbsp;:</strong></p>
<div class="line-block">
<div class="line">L&#8217;utilitaire fdisk de Linux permet de créer des partitions sur un disque dur.</div>
</div>
<div class="line-block">
<div class="line">Le partitionnement avec fdisk peut entraîner la perte de toutes les données présentes sur le disque sur lequel vous effectuez les opérations.</div>
</div>
<div class="line-block">
<div class="line">Il prend comme argument le chemin du fichier spécial associé au disque. À défaut, il utilisera le premier disque trouvé.</div>
</div>
<div class="line-block">
<div class="line">Cet utilitaire était un programme indépendant GNU fdisk (jusqu&#8217;à sa version 2.0 de décembre 2011) mais a été depuis intégré dans la suite GNU util-linux.</div>
</div>
<div class="line-block">
<div class="line">Le nom des périphériques de stockage varie selon qu&#8217;il s&#8217;agit de disques SCSI ou IDE.</div>
</div>
<ul class="simple">
<li>Pour des disques IDE, le premier sera nommé hda, le second hdb…</li>
<li>Pour des disques SCSI, le premier s&#8217;appellera sda, le second sdb…</li>
</ul>
<div class="line-block">
<div class="line">Exemple de commande avec fdisk :</div>
</div>
<div class="line-block">
<div class="line">Pour lister les partition on peut utiliser la comande :</div>
</div>
<div class="line-block">
<div class="line"><code class="docutils literal"><span class="pre">fdisk</span> <span class="pre">-l</span></code></div>
</div>
<div class="line-block">
<div class="line">la commande fdisk peut être utiliser avec la commande blkid pour obtenir des information sur le complémentaire sur le disk tel que son UUiD ou ses attributs.</div>
<div class="line"><code class="docutils literal"><span class="pre">blkid</span> <span class="pre">/dev/sda1</span></code></div>
</div>
<div class="line-block">
<div class="line">Pour utiliser l&#8217;outil de partitionnement on utilise la la commande fdisk et on choisis le disk que l&#8217;on veut partitionner.</div>
</div>
<div class="line-block">
<div class="line"><code class="docutils literal"><span class="pre">fdisk</span> <span class="pre">/dev/sda</span></code></div>
</div>
<div class="line-block">
<div class="line">Les commandes de fdisk sont appelées par des touches, voici la liste des plus importantes&nbsp;:</div>
</div>
<ul class="simple">
<li>d&nbsp;: destruction d&#8217;une partition</li>
<li>l&nbsp;: liste des types de partitions</li>
<li>m&nbsp;: impression du menu en cours</li>
<li>n&nbsp;: création d&#8217;une nouvelle partition</li>
<li>p&nbsp;: affichage des partitions</li>
<li>q&nbsp;: sortie de fdisk sans sauvegarde des paramètres</li>
<li>t&nbsp;: modification du type de partition</li>
<li>v&nbsp;: vérification de la table des partitions</li>
<li>w&nbsp;: sauvegarde des modifications et sortie de fdisk</li>
</ul>
<p>Si ont veut juste crée une partiton de type ext nous avons juste besoin de crée une partiton via fdisk.
puis d&#8217;utilisé mkfs pour lui donner le type de la partiton.</p>
<div class="line-block">
<div class="line"><code class="docutils literal"><span class="pre">mkfs.ext4</span> <span class="pre">/dev/sdb1</span></code></div>
</div>
<p>on pourra vérifier la crée de la partiton avec la commande :</p>
<div class="line-block">
<div class="line"><code class="docutils literal"><span class="pre">blkid</span></code></div>
</div>
<div class="line-block">
<div class="line">On aura plus qu&#8217;a monter la partition à l&#8217;aide de la commande mount et de lui affecter un repertoire.</div>
<div class="line">Pour ne pas avoir besoin de remonter le disque à chaque démarrage il faudra changer le fstab.</div>
</div>
<div class="section" id="source">
<h3>source :<a class="headerlink" href="#source" title="Lien permanent vers ce titre">¶</a></h3>
<div class="line-block">
<div class="line"><a class="reference external" href="http://lea-linux.org/documentations/Fstab">http://lea-linux.org/documentations/Fstab</a></div>
<div class="line"><a class="reference external" href="http://www.linux-france.org/article/cel/alcove/etude-fichiers.html/ch1.html">http://www.linux-france.org/article/cel/alcove/etude-fichiers.html/ch1.html</a></div>
<div class="line"><a class="reference external" href="http://www.tecmint.com/fdisk-commands-to-manage-linux-disk-partitions/">http://www.tecmint.com/fdisk-commands-to-manage-linux-disk-partitions/</a></div>
<div class="line"><a class="reference external" href="https://www.ibisc.univ-evry.fr/~petit/Enseignement/AdminSystem/IUP-ASR/2004-2005/snapshot.pdf">https://www.ibisc.univ-evry.fr/~petit/Enseignement/AdminSystem/IUP-ASR/2004-2005/snapshot.pdf</a></div>
<div class="line"><a class="reference external" href="http://www.misfu.com/installation-configuration-nfs-linux.html">http://www.misfu.com/installation-configuration-nfs-linux.html</a></div>
<div class="line"><a class="reference external" href="https://fr.wikipedia.org/wiki/Network_File_System">https://fr.wikipedia.org/wiki/Network_File_System</a></div>
<div class="line"><a class="reference external" href="https://doc.ubuntu-fr.org/btrfs">https://doc.ubuntu-fr.org/btrfs</a></div>
<div class="line"><a class="reference external" href="https://fr.wikipedia.org/wiki/Network_File_System">https://fr.wikipedia.org/wiki/Network_File_System</a></div>
<div class="line"><a class="reference external" href="https://fr.wikipedia.org/wiki/Syst%C3%A8me_de_fichiers_distribu%C3%A9">https://fr.wikipedia.org/wiki/Syst%C3%A8me_de_fichiers_distribu%C3%A9</a></div>
<div class="line"><a class="reference external" href="https://fr.wikipedia.org/wiki/Point_de_montage">https://fr.wikipedia.org/wiki/Point_de_montage</a></div>
<div class="line"><a class="reference external" href="https://fr.wikipedia.org/wiki/Ext4">https://fr.wikipedia.org/wiki/Ext4</a></div>
<div class="line"><a class="reference external" href="https://fr.wikipedia.org/wiki/Ext2">https://fr.wikipedia.org/wiki/Ext2</a></div>
<div class="line"><a class="reference external" href="https://fr.wikipedia.org/wiki/Disque_virtuel">https://fr.wikipedia.org/wiki/Disque_virtuel</a></div>
<div class="line"><a class="reference external" href="https://fr.wikipedia.org/wiki/Instantan%C3%A9_(informatique">https://fr.wikipedia.org/wiki/Instantan%C3%A9_(informatique</a>)</div>
<div class="line"><a class="reference external" href="https://fr.wikipedia.org/wiki/Fstab">https://fr.wikipedia.org/wiki/Fstab</a></div>
<div class="line"><a class="reference external" href="https://fr.wikipedia.org/wiki/Fdisk">https://fr.wikipedia.org/wiki/Fdisk</a></div>
<div class="line"><a class="reference external" href="https://fr.wikipedia.org/wiki/D%C3%A9fragmentation_(informatique">https://fr.wikipedia.org/wiki/D%C3%A9fragmentation_(informatique</a>)</div>
<div class="line"><a class="reference external" href="https://fr.wikipedia.org/wiki/XFS">https://fr.wikipedia.org/wiki/XFS</a></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index général"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="#">documentation Partitionnement et systeme de fichiers 0.0.1</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, Geoffroy Berry, Mohamed Missaoui.
      Créé avec <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>